---
title: "Project_version1"
author: "Namrata R"
date: "09/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
#install.packages("tidyverse")
#library(tidyverse)
library(grid)
library(gridExtra)
library(dplyr)
```
## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
train = read.csv('C:\\Users\\rames\\OneDrive\\Desktop\\namma\\DA_proj\\costa-rican-household-poverty-prediction (1)\\train.csv')
test = read.csv('C:\\Users\\rames\\OneDrive\\Desktop\\namma\\DA_proj\\costa-rican-household-poverty-prediction (1)\\test.csv')

#head(train)
```

```{r}
#summary(test)
#summary(train)
colnames(train)
#finding empty values
table(is.na(train))

#finding no of empty values for each column
#sapply(train, function(x) sum(is.na(x)))

na_count <- sort(colSums(is.na(train)),decreasing = TRUE)
na_count <- data.frame(names=names(na_count), count=na_count)
print(na_count)

table(is.na(test))

#finding no of empty values for each column
#sapply(train, function(x) sum(is.na(x)))

na_count1 <- sort(colSums(is.na(test)),decreasing = TRUE)
na_count1 <- data.frame(names=names(na_count1), count=na_count1)
print(na_count1)
```
```{r}
#subsetting dataset to get only columns with members being head of household as they determine the target variable
target<-subset(train, parentesco1==1)
#dim(target)

# getting count of the level of poverty(target variabvle) to see distribution
cat("total number of rows with each classified target\n")
table(target$Target)
barplot(table(target$Target))

#checking consistency of data, if all members of a given household belong to same target
#split(train, with(train, interaction(idhogar)), drop = TRUE)

#to handle this inconsistency, all other members will have same target value as the head

new_train<-train %>%
	group_by(idhogar)%>%
  arrange(desc(parentesco1),.by_group = TRUE)%>%
  #filter(parentesco1==1)%>%
  #select(parentesco1,idhogar,Target)%>%
  mutate(Target=Target[1])#%>%
  #filter(idhogar=='0172ab1d9')
  #arrange(desc(parentesco1))#%>%

#new_train
# handling cases which dont have head of family 
cat("\nNumber of households with no heads:\n")
nrow(train %>%
	group_by(idhogar)%>%
  summarise(parentesco1_sum = sum(parentesco1))%>%
  filter(parentesco1_sum==0))
  
check_train<-train %>%
	group_by(idhogar)%>%
  mutate(parentesco1_sum=sum(parentesco1))%>%
  #summarise(parentesco1_sum = sum(parentesco1))%>%
  filter(parentesco1_sum==0)%>%
   filter(length(unique(Target))>1)%>%
  select(parentesco1,idhogar,Target)

cat("no of rows in the subset that shows Households with no heads, having different labels.\n")
nrow(check_train)
  
cat("observation: since nrow of this data subset is 0(no data): the target variables are all identical for members without head of the family, hence no additional change needs to be made \n")

#finally checking if each houshold entry has same label
cat("Finally seeing number of household entries with different labels:")
nrow(new_train %>%
	group_by(idhogar)%>%
  filter(length(unique(Target))>1))

cat("As zero entries, the given subtask is completed")

```
```{r}
cat("Handling categorical and non numeric data values \n")
#class(new_train$dependency)
#new_train %>% select_if(funs(!is.numeric(.))) %>% head()
colnames(new_train %>%  select_if(is.factor))

cat("\nit can be seen 5 columns have type factor: out of which idhogar and Id can be ignored as they are unique values to distinguish between rows")
```
```{r}
newdata <- subset(new_train,select=c(dependency, edjefe,edjefa))
```
```{r}

#entires given as yes mostly refer to those which have ratio with denominator as 0 , hence we are replacing them by 1 ( for example i n dependency column saying that they depend on themselves hence 1. 
sort(unique(newdata$dependency))
new_train$dependency <- as.character(new_train$dependency)
new_train$dependency[which(new_train$dependency=="yes")] <- "1"
new_train$dependency[which(new_train$dependency=="no")] <- "0"
new_train$dependency <- as.numeric(new_train$dependency)

new_train$edjefe <- as.character(new_train$edjefe)
new_train$edjefe[which(new_train$edjefe=="yes")] <- "1"
new_train$edjefe[which(new_train$edjefe=="no")] <- "0"
new_train$edjefe <- as.numeric(new_train$edjefe)

new_train$edjefa <- as.character(new_train$edjefa)
new_train$edjefa[which(new_train$edjefa=="yes")] <- "1"
new_train$edjefa[which(new_train$edjefa=="no")] <- "0"
new_train$edjefa <- as.numeric(new_train$edjefa)

new_train_data<- subset(new_train,select=c(dependency, edjefe,edjefa))
sort(unique(new_train_data$dependency))
```
```{r}
new_train %>%  select_if(is.factor)
summary(new_train_data)
```
