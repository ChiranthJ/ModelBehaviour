---
title: "Project_version1"
author: "Namrata R"
date: "09/10/2019"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```


```{r}
#install.packages("tidyverse")
#library(tidyverse)
library(grid)
library(gridExtra)
#library(plyr)
library(dplyr)
#library(plyr)
```
## R Markdown

This is an R Markdown document. Markdown is a simple formatting syntax for authoring HTML, PDF, and MS Word documents. For more details on using R Markdown see <http://rmarkdown.rstudio.com>.

When you click the **Knit** button a document will be generated that includes both content as well as the output of any embedded R code chunks within the document. You can embed an R code chunk like this:

```{r}
train = read.csv('C:\\Users\\rames\\OneDrive\\Desktop\\namma\\DA_proj\\costa-rican-household-poverty-prediction (1)\\train.csv')
test = read.csv('C:\\Users\\rames\\OneDrive\\Desktop\\namma\\DA_proj\\costa-rican-household-poverty-prediction (1)\\test.csv')

#head(train)
```

```{r}
#summary(test)
#summary(train)
colnames(train)
#finding empty values
table(is.na(train))

#finding no of empty values for each column
#sapply(train, function(x) sum(is.na(x)))

na_count <- sort(colSums(is.na(train)),decreasing = TRUE)
na_count <- data.frame(names=names(na_count), count=na_count)
#print(na_count)
print(na_count[na_count$count>0, ])

table(is.na(test))

#finding no of empty values for each column
#sapply(train, function(x) sum(is.na(x)))

na_count1 <- sort(colSums(is.na(test)),decreasing = TRUE)
na_count1 <- data.frame(names=names(na_count1), count=na_count1)
#print(na_count)
```
```{r}
#subsetting dataset to get only columns with members being head of household as they determine the target variable
target<-subset(train, parentesco1==1)
#dim(target)

# getting count of the level of poverty(target variabvle) to see distribution
cat("total number of rows with each classified target\n")
table(target$Target)
barplot(table(target$Target))

#checking consistency of data, if all members of a given household belong to same target
#split(train, with(train, interaction(idhogar)), drop = TRUE)

#to handle this inconsistency, all other members will have same target value as the head

new_train<-train %>%
	group_by(idhogar)%>%
  arrange(desc(parentesco1),.by_group = TRUE)%>%
  #filter(parentesco1==1)%>%
  #select(parentesco1,idhogar,Target)%>%
  mutate(Target=Target[1])#%>%
  #filter(idhogar=='0172ab1d9')
  #arrange(desc(parentesco1))#%>%

#new_train
# handling cases which dont have head of family 
cat("\nNumber of households with no heads:\n")
nrow(train %>%
	group_by(idhogar)%>%
  summarise(parentesco1_sum = sum(parentesco1))%>%
  filter(parentesco1_sum==0))
  
check_train<-train %>%
	group_by(idhogar)%>%
  mutate(parentesco1_sum=sum(parentesco1))%>%
  #summarise(parentesco1_sum = sum(parentesco1))%>%
  filter(parentesco1_sum==0)%>%
   filter(length(unique(Target))>1)%>%
  select(parentesco1,idhogar,Target)

cat("no of rows in the subset that shows Households with no heads, having different labels.\n")
nrow(check_train)
  
cat("observation: since nrow of this data subset is 0(no data): the target variables are all identical for members without head of the family, hence no additional change needs to be made \n")

#finally checking if each houshold entry has same label
cat("Finally seeing number of household entries with different labels:")
nrow(new_train %>%
	group_by(idhogar)%>%
  filter(length(unique(Target))>1))

cat("As zero entries, the given subtask is completed")

```
```{r}
cat("Handling categorical and non numeric data values \n")
#class(new_train$dependency)
#new_train %>% select_if(funs(!is.numeric(.))) %>% head()
colnames(new_train %>%  select_if(is.factor))

cat("\nit can be seen 5 columns have type factor: out of which idhogar and Id can be ignored as they are unique values to distinguish between rows")
```
```{r}
newdata <- subset(new_train,select=c(dependency, edjefe,edjefa))
subset(train,select=c(dependency,SQBdependency,edjefe,SQBedjefe))
cat(" with this subset it can be observed that all no's in dependency correspond to 0 in the SQBdependency column similarly 'yes': correspnds to one. Hence , replacing all yes with 1 and no with 0 for the three factoor columns")
```
```{r}
cat("all unique values dependency, edjefe, edjefa take:\n")
sort(unique(newdata$dependency))
sort(unique(newdata$edjefe))
sort(unique(newdata$edjefa))

new_train$dependency <- as.character(new_train$dependency)
new_train$dependency[which(new_train$dependency=="yes")] <- "1"
new_train$dependency[which(new_train$dependency=="no")] <- "0"
new_train$dependency <- as.numeric(new_train$dependency)

new_train$edjefe <- as.character(new_train$edjefe)
new_train$edjefe[which(new_train$edjefe=="yes")] <- "1"
new_train$edjefe[which(new_train$edjefe=="no")] <- "0"
new_train$edjefe <- as.numeric(new_train$edjefe)

new_train$edjefa <- as.character(new_train$edjefa)
new_train$edjefa[which(new_train$edjefa=="yes")] <- "1"
new_train$edjefa[which(new_train$edjefa=="no")] <- "0"
new_train$edjefa <- as.numeric(new_train$edjefa)

new_train_data<- subset(new_train,select=c(dependency, edjefe,edjefa))
cat("\nall unique values dependency, edjefe, edjefa take after replacing yes and no:\n")
sort(unique(new_train_data$dependency))
sort(unique(new_train_data$edjefe))
sort(unique(new_train_data$edjefa))
```
```{r}
new_train %>%  select_if(is.factor)
summary(new_train_data)
```
```{r}
cat("Handling missing values\n")

na_count[na_count$count>0, ]

#handling rez_esc
cat("proportion of values missing in rez_esc(Years behind in school):\n")
print(na_count$count[1]/nrow(new_train))

#in this missing dataset, checking who all are actually students, and who all dont belong to schooling age(as suggested for other columns(7 to 19) ) (default set to 0)

new_DF <- subset(new_train, !is.na(new_train$rez_esc))
new_DF1 <- subset(new_train, is.na(new_train$rez_esc))
summary(new_DF$age)
summary(new_DF1$age)
cat("since the range of filled values are between age groups of 7 to 17, we can assume that for ages above or below this be given default 0 value")

#sort(new_DF1$age)
#subset(new_DF1, age>6 & age<19)
#new_DF1[new_DF1$date>4 & df$date<6, ]

```


```{r}
new_train$rez_esc[is.na(new_train$rez_esc) & (new_train$age<7 | new_train$age>17)]<-0    
```

```{r}
new_DF <- subset(new_train, !is.na(new_train$rez_esc))
new_DF1 <- subset(new_train, is.na(new_train$rez_esc))
summary(new_DF$age)
summary(new_DF1$age)
#a<- subset(new_train,is.na(rez_esc))['Id']
#a<-str(a['Id'])

cat("since there is only 1 row within the schooling age which has the rez_esc as NA, we will replace this with mean of other values it")

new_train$rez_esc[is.na(new_train$rez_esc)]<-mean(new_train$rez_esc, na.rm=TRUE)

```
```{r}
nrow(subset(new_train, is.na(new_train$rez_esc)))
cat("since nrow value is 0 all missing values have been taken care of in this column")
na_count <- sort(colSums(is.na(new_train)),decreasing = TRUE)
na_count <- data.frame(names=names(na_count), count=na_count)
#print(na_count)
print(na_count[na_count$count>0, ])

```

```{r}
#handling missing values in v18q1 : number of tablets owned by a family.
new_train %>%
    group_by(v18q1) %>%
    summarise(count=n())
cat("there are 2 possibilities as to why the value is NA 1) The data hasnt been filled 2) The no of tablets owned is 0\n since v18q column tells whether or not the household owns a laptop,we will compare to see if NA values in v18q1 correspons to 0 in v18q")

subset(new_train,select=c(v18q,v18q1))[new_train$v18q==0,] %>%
    distinct(v18q, v18q1, .keep_all = TRUE)

cat(" since each 0 value in v18q is mapped to NA in v18q1, we can fill NAs in v18q1 with 0 and discard column v18q")

new_train$v18q1[is.na(new_train$v18q1)]<-0
```

```{r}
temp <- subset(new_train, is.na(new_train$v18q1))
nrow(temp)
cat("missing values for this column have been taken care of")
na_count <- sort(colSums(is.na(new_train)),decreasing = TRUE)
na_count <- data.frame(names=names(na_count), count=na_count)
#print(na_count)
print(na_count[na_count$count>0, ])
```
```{r}
#handling missing values in v2a1 : Monthly rent payment


```

